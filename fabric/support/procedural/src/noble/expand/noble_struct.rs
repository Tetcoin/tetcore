// This file is part of Tetcore.

// Copyright (C) 2020-2021 Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: Apache-2.0

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::noble::Def;

/// * Add derive trait on Noble
/// * Implement GetNobleVersion on Noble
/// * Implement OnGenesis on Noble
/// * Implement ModuleErrorMetadata on Noble
/// * declare Module type alias for construct_runtime
pub fn expand_noble_struct(def: &mut Def) -> proc_macro2::TokenStream {
	let fabric_support = &def.fabric_support;
	let fabric_system = &def.fabric_system;
	let type_impl_gen = &def.type_impl_generics(def.noble_struct.attr_span);
	let type_use_gen = &def.type_use_generics(def.noble_struct.attr_span);
	let type_decl_gen = &def.type_decl_generics(def.noble_struct.attr_span);
	let noble_ident = &def.noble_struct.noble;
	let config_where_clause = &def.config.where_clause;

	let noble_item = {
		let noble_module_items = &mut def.item.content.as_mut().expect("Checked by def").1;
		let item = &mut noble_module_items[def.noble_struct.index];
		if let syn::Item::Struct(item) = item {
			item
		} else {
			unreachable!("Checked by noble struct parser")
		}
	};

	noble_item.attrs.push(syn::parse_quote!(
		#[derive(
			#fabric_support::CloneNoBound,
			#fabric_support::EqNoBound,
			#fabric_support::PartialEqNoBound,
			#fabric_support::RuntimeDebugNoBound,
		)]
	));

	let module_error_metadata = if let Some(error_def) = &def.error {
		let error_ident = &error_def.error;
		quote::quote_spanned!(def.noble_struct.attr_span =>
			impl<#type_impl_gen> #fabric_support::error::ModuleErrorMetadata
				for #noble_ident<#type_use_gen>
				#config_where_clause
			{
				fn metadata() -> &'static [#fabric_support::error::ErrorMetadata] {
					<
						#error_ident<#type_use_gen> as #fabric_support::error::ModuleErrorMetadata
					>::metadata()
				}
			}
		)
	} else {
		quote::quote_spanned!(def.noble_struct.attr_span =>
			impl<#type_impl_gen> #fabric_support::error::ModuleErrorMetadata
				for #noble_ident<#type_use_gen>
				#config_where_clause
			{
				fn metadata() -> &'static [#fabric_support::error::ErrorMetadata] {
					&[]
				}
			}
		)
	};

	quote::quote_spanned!(def.noble_struct.attr_span =>
		#module_error_metadata

		/// Type alias to `Noble`, to be used by `construct_runtime`.
		///
		/// Generated by `noble` attribute macro.
		pub type Module<#type_decl_gen> = #noble_ident<#type_use_gen>;

		// Implement `GetNobleVersion` for `Noble`
		impl<#type_impl_gen> #fabric_support::traits::GetNobleVersion
			for #noble_ident<#type_use_gen>
			#config_where_clause
		{
			fn current_version() -> #fabric_support::traits::NobleVersion {
				#fabric_support::crate_to_noble_version!()
			}

			fn storage_version() -> Option<#fabric_support::traits::NobleVersion> {
				let key = #fabric_support::traits::NobleVersion::storage_key::<
						<T as #fabric_system::Config>::NobleInfo, Self
					>().expect("Every active noble has a name in the runtime; qed");

				#fabric_support::storage::unhashed::get(&key)
			}
		}

		// Implement `OnGenesis` for `Noble`
		impl<#type_impl_gen> #fabric_support::traits::OnGenesis
			for #noble_ident<#type_use_gen>
			#config_where_clause
		{
			fn on_genesis() {
				#fabric_support::crate_to_noble_version!()
					.put_into_storage::<<T as #fabric_system::Config>::NobleInfo, Self>();
			}
		}
	)
}
